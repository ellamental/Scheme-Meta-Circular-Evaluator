;;#!/usr/local/bin/csi
;;__________________________________________________________________________;;
;; meta
;; meta.chicken | 2010-08-04
;; (load "~/Documents/meta/meta.chicken")
;; 
;; An interpreter for a Scheme-like language based mostly off the 
;; meta-circular evaluator found in SICP
;; 
;; Recent Changes:
;;
;;
;; TODO:
;; 
;;__________________________________________________________________________;;

(define (Error #!rest args) False)

;;__________________________________________________________________________;;
;; Type System
;; 
;; Each object is a cons cell with the (car = type) (cdr = data).
;; This is subject to change considerably.  Use the type operators 
;; type, type?, object-data and make-type exclusivley to interact with types.
;;__________________________________________________________________________;;


(define (make-type type expression)
  (cons type expression))

(define (type object)
  (cond ((symbol? object) 'symbol)
        ((number? object) 'number)
        ((string? object) 'string)
        (else (car object))))

(define (type? object . types)
  (member (type object) types))

(define (object-data object)
  (cdr object))

;;__________________________________________________________________________;;
;; Booleans and Predicates
;;__________________________________________________________________________;;

(define Void 'Void)
(define &args '&args)
(define >>> '>>>)

(define True 'True)
(define False 'False)
(define (true? exp) (not (eq? exp False)))
(define (false? exp) (eq? exp False))


;;__________________________________________________________________________;;
;; Environments and Frames
;; 
;; Environments consist of two parts, a frame and an enclosing environment.
;; All bindings to variables are stored within the frame
;;__________________________________________________________________________;;

(define the-empty-environment '())
(define (current-environment env) (car env))
(define (enclosing-environment env) (cdr env))

(define (make-frame bindings)
  (alist->hash-table bindings))

(define (add-binding-to-frame! var value frame)
  (hash-table-set! frame var value))

(define (extend-environment bindings base-environment)
  (cons (make-frame bindings) base-environment))


;; Lookup and Set Procedures
;;_______________________________________________________;;

(define (lookup-variable-value variable environment)
  (if (eq? environment the-empty-environment)
    (Error (print "Unbound variable:  " variable))
    (if (hash-table-exists? (current-environment environment) variable)
        (hash-table-ref (current-environment environment) variable)
        (lookup-variable-value variable (enclosing-environment environment)))))
  
(define (set-variable! variable value environment)
  (add-binding-to-frame! variable value (current-environment environment)))


;;__________________________________________________________________________;;
;; Eval and Apply
;;__________________________________________________________________________;;

;; meta-eval evaluates an expression in an environment
;; meta-eval uses global-syntax-definitions
(define (meta-eval exp env)
  (cond ((type? exp 'number 'string) exp)
        ((type? exp 'symbol) (lookup-variable-value exp env))               
        (else
          (let ((name (car exp)))
          (cond ((hash-table-exists? global-syntax-definitions name)
                  ((hash-table-ref global-syntax-definitions name) exp env)) 
                (else (meta-apply (meta-eval (car exp) env)
                                  (eval-arguments (cdr exp) env))))))))

;; eval-arguments evaluates each expression in exps and returns a list of 
;; the values.  It is used to supply a list of values to meta-apply.
(define (eval-arguments exps env)
  (if (null? exps)
      '()
      (cons (meta-eval (car exps) env)
            (eval-arguments (cdr exps) env))))

;; eval-sequence evaluates all expressions in order and returns the value
;; of the last expression evaluated.  It is used by meta-eval and begin.
(define (eval-sequence expressions env)
  (if (null? (cdr expressions)) (meta-eval (car expressions) env)
                                (begin
                                (meta-eval (car expressions) env)
                                  (eval-sequence (cdr expressions) env))))

(define (meta-apply procedure arguments) 
  (cond ((type? procedure 'primitive)
          (apply (cdr procedure) arguments))
        ((type? procedure 'procedure)
          (let ((arg-vals (assign-values procedure arguments)))
            (if (false? arg-vals) Void
                (eval-sequence (caddr procedure)
                               (extend-environment arg-vals
                                                   (cadddr procedure))))))
    ))

;; Allow use of &args for variable arity procedures
(define (assign-values procedure val-list)
  (define (loop arg-list val-list result-list)
    (if (null? (cdr arg-list))                                  ;; Check for the end of argument list
        (if (null? (cdr val-list))                              ;; Check if value list is null too
            (reverse (cons (cons (car arg-list)
                                 (car val-list))
                           result-list))                        ;; If it is return result-list
            (if (eq? (car arg-list) &args)                      ;; Check if last argument was &args
                (reverse (cons (cons (car arg-list) val-list)
                               result-list))                    ;; If it was return result-list
                (Error (print "Too many values"))))
        (loop (cdr arg-list)
              (cdr val-list)                                    ;; If not at end of args
              (cons (cons (car arg-list)                        ;; Create a pair of (arg . value)
                          (car val-list))
                    result-list))))                             ;; and cons it onto result-list
  (define args (cadr procedure))
  
  (cond ((null? args)                                           ;; Check for no argument procedures
           (if (null? val-list)
               '()
               (Error (print "Too many values"))))
        ((>= (length val-list) (length args))                   ;; Check for enough values
           (loop args val-list '()))
        (else
           (Error (print "Too few values")))))



;;__________________________________________________________________________;;
;; Primitive Syntax Definitions
;;__________________________________________________________________________;;


(define global-syntax-definitions (make-hash-table))
(define (add-syntax name procedure) 
  (hash-table-set! global-syntax-definitions name procedure))

;; quote
(add-syntax 'quote (lambda (exp env) (cadr exp)))

;; define
(define (eval-definition exp env)
  (define (eval-lambda-definition)
    (let ((name (caadr exp))
          (args (cdadr exp))
          (body (cddr exp)))
      (set-variable! name (list 'procedure args body env) env)))
  (if (symbol? (cadr exp))
    (set-variable! (cadr exp) (meta-eval (caddr exp) env) env)
    (eval-lambda-definition))
  Void)
(add-syntax 'define eval-definition)

;; if
(define (eval-if exp env)
  (if (true? (meta-eval (cadr exp) env))
      (meta-eval (caddr exp) env)
      (meta-eval (cadddr exp) env)))
(add-syntax 'if eval-if)

;; lambda
(define (eval-lambda exp env)
  (list 'procedure (cadr exp) (cddr exp) env))
(add-syntax 'lambda eval-lambda)

;; begin
(add-syntax 'begin (lambda (exp env) (eval-sequence (cdr exp) env)))

;; scheme
;; Allows scheme expressions to be evaluated.  There are no hooks into/out of scheme.
(add-syntax 'scheme (lambda (exp env) (eval (cadr exp))))

;;__________________________________________________________________________;;
;; Setup the Global Environment
;;__________________________________________________________________________;;

(define the-global-environment (extend-environment '() the-empty-environment))

;; set-self sets a self-evaluating symbol in the-global-environment
(define (set-self sym func)
  (set-variable! sym func the-global-environment))

(set-self 'True True)
(set-self 'False False)
(set-self 'the-empty-list '())
(set-self 'Void Void)
(set-self '&args &args)
(set-self '>>> >>>)

;; set sets a primitive procedure in the-global-environment
(define (set sym func)
  (set-variable! sym (cons 'primitive func) the-global-environment))

(define (->bool obj) (if object True False))

;; Primitive Procedures
;;_____________________________________________;;

;; null?
(define (meta-null? a) (->bool (null? a)))
(set 'null? meta-null?)

;; equal?
(define (meta-equal? a b) (->bool (equal? a b)))
(set 'equal? meta-equal?)

;; print
(define (meta-print . exps) (apply print exps) Void)
(set 'print meta-print)


;; Primitive List Procedures
;;_____________________________________________;;

(set 'cons cons)
(set 'car car)
(set 'cdr cdr)

;; Primitive Number Procedures
;;_____________________________________________;;

(set '+ +)
(set '- -)
(set '/ /)
(set '* *)

;; Access to the type system
;;_____________________________________________;;

(set 'type type)
(set 'type? type?)


;;__________________________________________________________________________;;
;; REPL
;;__________________________________________________________________________;;


(define (REPL)
  (display ": ")
  (let ((input (read)))
    (let ((output (meta-eval input the-global-environment)))
      (if (eq? output Void) (REPL)
                            (user-print output))))
  (REPL))

(define (user-print object)
  (print object))


;; Comment out (REPL) for debugging or using as a library
(REPL)


