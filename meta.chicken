;;#!/usr/local/bin/csi
;;__________________________________________________________________________;;
;; meta
;; meta.chicken | 2010-08-04
;; (load "~/Documents/meta/meta.chicken")
;; 
;; An interpreter for a Scheme-like language based mostly off the 
;; meta-circular evaluator found in SICP
;; 
;; Recent Changes:
;;
;;
;; TODO:
;; 
;;__________________________________________________________________________;;

(define (Error #!rest args) False)

;;__________________________________________________________________________;;
;; Type System
;; 
;; Each object is a cons cell with the (car = type) (cdr = data).
;; This is subject to change considerably.  Use the type operators 
;; type, type?, object-data and make-type exclusivley to interact with types.
;;__________________________________________________________________________;;



(define (make-type type expression)
  (cons type expression))

(define (type object)
  (car object))

(define (type? object quoted-type)
  (equal? (type object) quoted-type))

(define (object-data object)
  (cdr object))

;;__________________________________________________________________________;;
;; Booleans and Predicates
;;__________________________________________________________________________;;

(define Void 'Void)
(define &args '&args)

(define True 'True)
(define False 'False)
(define (true? exp) (not (eq? exp False)))
(define (false? exp) (eq? exp False))

(define (self-evaluating? expression)
  (or (number? expression) (string? expression)))

(define (variable? expression)
  (symbol? expression))

(define (application? expression)
  (pair? expression))


;;__________________________________________________________________________;;
;; Eval and Apply
;;__________________________________________________________________________;;


(define (meta-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp)     (lookup-variable-value exp env))
        ((type? exp 'quote)  (cadr exp))
        ((type? exp 'define) (eval-definition exp env))
        ((type? exp 'if)     (eval-if exp env))
        ((type? exp 'lambda) (eval-lambda exp env))
        ((type? exp 'begin)  (eval-sequence (cdr exp) env))
        ((application? exp)  (meta-apply (meta-eval (car exp) env)
                                         (eval-arguments (cdr exp) env)))
    ))

(define (eval-arguments exps env)
  (if (null? exps)
      '()
      (cons (meta-eval (car exps) env)
            (eval-arguments (cdr exps) env))))

(define (eval-sequence expressions env)
  (if (null? (cdr expressions)) (meta-eval (car expressions) env)
                                (begin
                                (meta-eval (car expressions) env)
                                  (eval-sequence (cdr expressions) env))))

(define (eval-lambda exp env)
  (list 'procedure (cadr exp) (cddr exp) env))
  
(define (eval-definition exp env)
  (define (eval-lambda-definition)
    (let ((name (caadr exp))
          (args (cdadr exp))
          (body (cddr exp)))
      (set-variable! name (list 'procedure args body env) env)))
  
  (if (symbol? (cadr exp))
    (set-variable! (cadr exp) (meta-eval (caddr exp) env) env)
    (eval-lambda-definition))

  Void)

;; (if condition if-true if-false)
(define (eval-if exp env)
  (if (true? (meta-eval (cadr exp) env))
      (meta-eval (caddr exp) env)
      (meta-eval (cadddr exp) env)))



(define (meta-apply procedure arguments) 
  (cond ((type? procedure 'primitive)
          (apply (cdr procedure) arguments))
        ((type? procedure 'procedure)
          (let ((arg-vals (assign-values procedure arguments)))
            (if (false? arg-vals) Void
                (eval-sequence (caddr procedure)
                               (extend-environment arg-vals
                                                   (cadddr procedure))))))
    ))

;; Allow use of &args for variable arity procedures
(define (assign-values procedure val-list)
  (define (loop arg-list val-list result-list)
    (if (null? (cdr arg-list))                                  ;; Check for the end of argument list
        (if (null? (cdr val-list))                              ;; Check if value list is null too
            (reverse (cons (cons (car arg-list)
                                 (car val-list))
                           result-list))                        ;; If it is return result-list
            (if (eq? (car arg-list) &args)                      ;; Check if last argument was &args
                (reverse (cons (cons (car arg-list) val-list)
                               result-list))                    ;; If it was return result-list
                (Error (print "Too many values"))))
        (loop (cdr arg-list)
              (cdr val-list)                                    ;; If not at end of args
              (cons (cons (car arg-list)                        ;; Create a pair of (arg . value)
                          (car val-list))
                    result-list))))                             ;; and cons it onto result-list
  (define args (cadr procedure))
  
  (cond ((= (length args) 0)                                    ;; Check for no argument procedures
           (if (= (length val-list) 0)
               '()
               (Error (print "Too many values")))
        ((>= (length val-list) (length args))                   ;; Check for enough values
           (loop args val-list '()))
        (else
           (Error (print "Too few values")))))



;;__________________________________________________________________________;;
;; Environments and Frames
;; 
;; Environments consist of two parts, a frame and an enclosing environment.
;; All bindings to variables are stored within the frame
;;__________________________________________________________________________;;

(define the-empty-environment '())
(define (current-environment env) (car env))
(define (enclosing-environment env) (cdr env))

(define (make-frame bindings)
  (alist->hash-table bindings))

(define (add-binding-to-frame! var value frame)
  (hash-table-set! frame var value))

(define (extend-environment bindings base-environment)
  (cons (make-frame bindings) base-environment))


;; Lookup and Set Procedures
;;_______________________________________________________;;

(define (lookup-variable-value variable environment)
  (if (eq? environment the-empty-environment)
    (begin (print "Unbound variable:  " variable) Void)
    (if (hash-table-exists? (current-environment environment) variable)
        (hash-table-ref (current-environment environment) variable)
        (lookup-variable-value variable (enclosing-environment environment)))))
  
(define (set-variable! variable value environment)
  (add-binding-to-frame! variable value (current-environment environment)))




;;__________________________________________________________________________;;
;; Setup the Global Environment
;;__________________________________________________________________________;;

(define primitives '())

(define (setup-environment)
  (let ((initial-env (extend-environment primitives the-empty-environment)))
    (set-variable! 'True True initial-env)
    (set-variable! 'False False initial-env)
    (set-variable! 'the-empty-list '() initial-env)
    (set-variable! 'Void Void initial-env)
    (set-variable! '&args &args initial-env)
    (set-variable! 'null? (cons 'primitive null?) initial-env)
    (set-variable! 'equal? (cons 'primitive equal?) initial-env)
    (set-variable! 'print (cons 'primitive print) initial-env)
    (set-variable! 'cons (cons 'primitive cons) initial-env)
    (set-variable! 'car (cons 'primitive car) initial-env)
    (set-variable! 'cdr (cons 'primitive cdr) initial-env)
    (set-variable! 'type (cons 'primitive type) initial-env)
    (set-variable! 'type? (cons 'primitive type?) initial-env)
    initial-env))

(define the-global-environment (setup-environment))

;;__________________________________________________________________________;;
;; REPL
;;__________________________________________________________________________;;


(define (REPL)
  (display ": ")
  (let ((input (read)))
    (let ((output (meta-eval input the-global-environment)))
      (if (eq? output Void) (REPL)
                            (user-print output))))
  (REPL))

(define (user-print object)
  (print object))


;; Comment out (REPL) for debugging or using as a library
(REPL)


(define (a x)
  (define (b y) y)
  (b x))
; (define ...) should return Void
; (a 3) >>> 3
; b >>> Error 'unbound-variable
; 


(define (b x)
  (define (c) x)
  (c))
