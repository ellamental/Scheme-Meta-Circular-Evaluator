;;#!/usr/local/bin/csi
;;__________________________________________________________________________;;
;; meta
;; meta.chicken | 2010-08-04
;; (load "~/Documents/meta/meta.chicken")
;; 
;; An interpreter for a Scheme-like language based mostly off the 
;; meta-circular evaluator found in SICP
;; 
;; Recent Changes:
;;
;;
;; TODO:
;; 
;;__________________________________________________________________________;;

(define (Error #!rest args)
  (cons 'error args))

(define (error? object) (equal? (type object) 'error))

(define current-exception-handler #f)

;;__________________________________________________________________________;;
;; Type System
;; 
;; Each object is a cons cell with the (car = type) (cdr = data).
;; This is subject to change considerably.  Use the type operators 
;; type, type?, object-data and make-type exclusivley to interact with types.
;;__________________________________________________________________________;;


(define (make-type type expression)
  (cons type expression))

(define (type object)
  (cond ((symbol? object) 'symbol)
        ((number? object) 'number)
        ((string? object) 'string)
        (else (car object))))

(define (type? object . types)
  (member (type object) types))

(define (object-data object)
  (cdr object))

;;__________________________________________________________________________;;
;; Booleans and Predicates
;;__________________________________________________________________________;;

(define Void 'Void)
(define &args '&args)
(define >>> '>>>)

(define True 'True)
(define False 'False)
(define (true? exp) (not (eq? exp False)))
(define (false? exp) (eq? exp False))


;;__________________________________________________________________________;;
;; Environments and Frames
;; 
;; Environments consist of two parts, a frame and an enclosing environment.
;; All bindings to variables are stored within the frame
;;__________________________________________________________________________;;

(define the-empty-environment '())
(define (current-environment env) (car env))
(define (enclosing-environment env) (cdr env))

(define (make-frame bindings)
  (alist->hash-table bindings))

(define (add-binding-to-frame! var value frame)
  (hash-table-set! frame var value))

(define (extend-environment bindings base-environment)
  (cons (make-frame bindings) base-environment))


;; Lookup and Set Variables
;;_______________________________________________________;;

(define (lookup-variable-value variable environment)
  (if (eq? environment the-empty-environment)
    (Error 'unbound-variable "Unbound variable:  " variable)
    (if (hash-table-exists? (current-environment environment) variable)
        (hash-table-ref (current-environment environment) variable)
        (lookup-variable-value variable (enclosing-environment environment)))))
  
(define (set-variable! variable value environment)
  (add-binding-to-frame! variable value (current-environment environment)))


;;__________________________________________________________________________;;
;; Eval and Apply
;;__________________________________________________________________________;;

;; meta-eval evaluates an expression in an environment
;; meta-eval uses global-syntax-definitions
(define (meta-eval exp env)
  ;(print exp)
  (cond ((type? exp 'number 'string) exp)
        ((type? exp 'symbol) (lookup-variable-value exp env))               
        (else
          (let ((name (car exp)))
          (cond ((hash-table-exists? global-syntax-definitions name)
                  ((hash-table-ref global-syntax-definitions name) exp env)) 
                (else (meta-apply (meta-eval (car exp) env)
                                  (eval-arguments (cdr exp) env))))))))

;; eval-arguments evaluates each expression in exps and returns a list of 
;; the values.  It is used to supply a list of values to meta-apply.
(define (eval-arguments exps env)
  (if (null? exps)
      '()
      (cons (meta-eval (car exps) env)
            (eval-arguments (cdr exps) env))))

;; eval-sequence evaluates all expressions in order and returns the value
;; of the last expression evaluated.  It is used by meta-apply and begin.
(define (eval-sequence expressions env)
  (if (null? (cdr expressions)) (meta-eval (car expressions) env)
                                (begin
                                  (meta-eval (car expressions) env)
                                  (eval-sequence (cdr expressions) env))))

(define (meta-apply procedure arguments) 
  (cond ((type? procedure 'primitive)
          (apply (cdr procedure) arguments))
        ((type? procedure 'procedure)
          (let ((arg-vals (assign-values procedure arguments)))
            (cond ((type? arg-vals 'error) (meta-eval arg-vals (cadddr procedure)))   ;; break out of apply loop and return an error
                  (else
                    (eval-sequence (caddr procedure)
                                   (extend-environment arg-vals
                                                       (cadddr procedure)))))))
    ))


(define (assign-values procedure val-list)
  (define args (cadr procedure))
  (define length-diff (- (length val-list) (length args)))
  
  (define (car-pair x y) (cons (car x) (car y)))
  
  (define (handle-&args args vals result)
    (if (equal? (car args) &args)
        (cons (cons (car args) vals) result)
        (handle-&args (cdr args) (cdr vals) (cons (car-pair args vals) result)))) 
  
  (cond ((member &args args)
          (if (< length-diff -1) 
              (Error 'arity "Too few arguments" #\newline
                            "procedure-arguments:  " args #\newline
                            "supplied-arguments:   " val-list)
              (handle-&args args val-list '())))
        ((zero? length-diff)
          (map cons args val-list))
        ((negative? length-diff)
          (Error 'arity "Too few arguments" #\newline
                        "procedure-arguments:  " args #\newline
                        "supplied-arguments:   " val-list))
        ((positive? length-diff)
          (Error 'arity "Too many arguments" #\newline
                        "procedure-arguments:  " args #\newline
                        "supplied-arguments:   " val-list))))

          
;;__________________________________________________________________________;;
;; Primitive Syntax Definitions
;;__________________________________________________________________________;;


(define global-syntax-definitions (make-hash-table))
(define (add-syntax name procedure) 
  (hash-table-set! global-syntax-definitions name procedure))

;; quote
(add-syntax 'quote (lambda (exp env) (cadr exp)))

;; define
(define (eval-definition exp env)
  (define (eval-lambda-definition)
    (let ((name (caadr exp))
          (args (cdadr exp))
          (body (cddr exp)))
      (set-variable! name (list 'procedure args body env) env)))
  (if (symbol? (cadr exp))
    (set-variable! (cadr exp) (meta-eval (caddr exp) env) env)
    (eval-lambda-definition))
  Void)
(add-syntax 'define eval-definition)

;; if
(define (eval-if exp env)
  (if (true? (meta-eval (cadr exp) env))
      (meta-eval (caddr exp) env)
      (meta-eval (cadddr exp) env)))
(add-syntax 'if eval-if)

;; lambda
(define (eval-lambda exp env)
  (list 'procedure (cadr exp) (cddr exp) env))
(add-syntax 'lambda eval-lambda)

;; begin
(add-syntax 'begin (lambda (exp env) (eval-sequence (cdr exp) env)))

;; test
(define (test exp env)
  (define test-environment (extend-environment '() env))
  (define (test-loop expr)
    (if (null? expr) Void
        (begin
          (test-expr expr)
          (test-loop (cdddr expr)))))
  (define (test-expr expression)
    (let ((test-val (meta-eval (car expression) test-environment))
          (expected (meta-eval (caddr expression) test-environment)))
      (if (equal? test-val expected)
          True
          (print "#---------Error---------#" #\newline
                 (car expression) #\newline
                 "!= " (caddr expression)))))
  (test-loop (cdr exp)))
(add-syntax 'test test)

;; error
(define (meta-error exp env)
  (set! current-exception-handler (list (cadr exp) (cddr exp) env))
  (apply print (cddr exp))
  (REPL))
(add-syntax 'error meta-error)

;; scheme
;; This shows how easy it is to add new syntax
(add-syntax 'scheme (lambda (exp env) (eval (cadr exp))))


;;__________________________________________________________________________;;
;; Setup the Global Environment
;;__________________________________________________________________________;;

(define the-global-environment (extend-environment '() the-empty-environment))

;; set-self sets a self-evaluating symbol in the-global-environment
(define (set-self sym func)
  (set-variable! sym func the-global-environment))

(set-self 'True True)
(set-self 'False False)
(set-self 'the-empty-list '())
(set-self 'Void Void)
(set-self '&args &args)
(set-self '>>> >>>)

;; set sets a primitive procedure in the-global-environment
(define (set sym func)
  (set-variable! sym (cons 'primitive func) the-global-environment))

(define (->bool object) (if object True False))

;; Primitive Procedures
;;_____________________________________________;;

;; current-error-handler
;; Get the current exception and clear the handler
(define (meta-current-exception)
  (let ((x current-exception-handler))
    (begin 
      (set! current-exception-handler False)
      (car x))))
(set 'current-exception meta-current-exception)

;; clear-current-exception
(define (clear-current-exception)
  (set! current-exception-handler False)
  False)
(set 'clear-current-exception clear-current-exception)

;; load
(define (meta-load filename)
  (define f (open-input-file filename))
  (define (read-loop)
    (let ((e (read f)))
      (if (equal? e #!eof) "Successfully Loaded!"
                           (begin
                             (meta-eval e the-global-environment)
                             (read-loop)))))
  (read-loop))
(set 'load meta-load)

;; null?
(define (meta-null? a) (->bool (null? a)))
(set 'null? meta-null?)

;; equal?
(define (meta-equal? a b) (->bool (equal? a b)))
(set 'equal? meta-equal?)

;; print
(define (meta-print . exps) (apply print exps) Void)
(set 'print meta-print)


;; Primitive List Procedures
;;_____________________________________________;;

(set 'cons cons)
(set 'car car)
(set 'cdr cdr)

;; Primitive Number Procedures
;;_____________________________________________;;

(set '+ +)
(set '- -)
(set '/ /)
(set '* *)

;; Access to the type system
;;_____________________________________________;;

(set 'type type)
(set 'type? type?)


;;__________________________________________________________________________;;
;; REPL
;;__________________________________________________________________________;;


(define (REPL)
  (display ": ")
  (let ((input (read)))
    (let ((output (meta-eval input the-global-environment)))
      (if (eq? output Void) (REPL)
                            (user-print output))))
  (REPL))

(define (user-print object)
  (print object))


;; Comment out (REPL) for debugging or using as a library
(REPL)

