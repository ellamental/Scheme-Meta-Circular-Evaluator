;;#!/usr/local/bin/csi
;;__________________________________________________________________________;;
;; meta
;; meta.chicken | 2010-08-04
;; (load "~/Documents/meta/meta.chicken")
;; 
;; An interpreter for a Scheme-like language based mostly off the 
;; meta-circular evaluator found in SICP
;; 
;; Recent Changes:
;;
;;
;; TODO:
;; 
;;__________________________________________________________________________;;

(define (Error #!rest args) False)

(define (test test delim result)
  (equal? test result))

;;__________________________________________________________________________;;
;; Type System
;; 
;; Each object is a cons cell with the (car = type) (cdr = data).
;; This is subject to change considerably.  Use the type operators 
;; type, type?, object-data and make-type exclusivley to interact with types.
;;__________________________________________________________________________;;



(define (make-type type expression)
  (cons type expression))

(define (type object)
  (cond ((symbol? object) 'symbol)
        ((number? object) 'number)
        ((string? object) 'string)
        (else (car object))))

(define (type? object . types)
  (member (type object) types))

(define (object-data object)
  (cdr object))

;;__________________________________________________________________________;;
;; Booleans and Predicates
;;__________________________________________________________________________;;

(define Void 'Void)
(define &args '&args)
(define >>> '>>>)

(define True 'True)
(define False 'False)
(define (true? exp) (not (eq? exp False)))
(define (false? exp) (eq? exp False))

(define (application? expression)
  (pair? expression))


;;__________________________________________________________________________;;
;; Eval and Apply
;;__________________________________________________________________________;;




(define (meta-eval exp env)
  (cond ((type? exp 'number 'string) exp)
        ((type? exp 'symbol) (lookup-variable-value exp env))
        (else
          (let ((name (car exp)))
          (cond ((hash-table-exists? global-syntax-definitions name)
                  ((hash-table-ref global-syntax-definitions name) exp env)) 
                (else (meta-apply (meta-eval (car exp) env)
                                  (eval-arguments (cdr exp) env))))))))




(define (eval-arguments exps env)
  (if (null? exps)
      '()
      (cons (meta-eval (car exps) env)
            (eval-arguments (cdr exps) env))))

(define (eval-sequence expressions env)
  (if (null? (cdr expressions)) (meta-eval (car expressions) env)
                                (begin
                                (meta-eval (car expressions) env)
                                  (eval-sequence (cdr expressions) env))))

(define (eval-lambda exp env)
  (list 'procedure (cadr exp) (cddr exp) env))
  
(define (eval-definition exp env)
  (define (eval-lambda-definition)
    (let ((name (caadr exp))
          (args (cdadr exp))
          (body (cddr exp)))
      (set-variable! name (list 'procedure args body env) env)))
  
  (if (symbol? (cadr exp))
    (set-variable! (cadr exp) (meta-eval (caddr exp) env) env)
    (eval-lambda-definition))

  Void)

;; (if condition if-true if-false)
(define (eval-if exp env)
  (if (true? (meta-eval (cadr exp) env))
      (meta-eval (caddr exp) env)
      (meta-eval (cadddr exp) env)))



(define (meta-apply procedure arguments) 
  (cond ((type? procedure 'primitive)
          (apply (cdr procedure) arguments))
        ((type? procedure 'procedure)
          (let ((arg-vals (assign-values procedure arguments)))
            (if (false? arg-vals) Void
                (eval-sequence (caddr procedure)
                               (extend-environment arg-vals
                                                   (cadddr procedure))))))
    ))

;; Allow use of &args for variable arity procedures
(define (assign-values procedure val-list)
  (define (loop arg-list val-list result-list)
    (if (null? (cdr arg-list))                                  ;; Check for the end of argument list
        (if (null? (cdr val-list))                              ;; Check if value list is null too
            (reverse (cons (cons (car arg-list)
                                 (car val-list))
                           result-list))                        ;; If it is return result-list
            (if (eq? (car arg-list) &args)                      ;; Check if last argument was &args
                (reverse (cons (cons (car arg-list) val-list)
                               result-list))                    ;; If it was return result-list
                (Error (print "Too many values"))))
        (loop (cdr arg-list)
              (cdr val-list)                                    ;; If not at end of args
              (cons (cons (car arg-list)                        ;; Create a pair of (arg . value)
                          (car val-list))
                    result-list))))                             ;; and cons it onto result-list
  (define args (cadr procedure))
  
  (cond ((null? args)                                           ;; Check for no argument procedures
           (if (null? val-list)
               '()
               (Error (print "Too many values"))))
        ((>= (length val-list) (length args))                   ;; Check for enough values
           (loop args val-list '()))
        (else
           (Error (print "Too few values")))))



;;__________________________________________________________________________;;
;; Environments and Frames
;; 
;; Environments consist of two parts, a frame and an enclosing environment.
;; All bindings to variables are stored within the frame
;;__________________________________________________________________________;;

(define the-empty-environment '())
(define (current-environment env) (car env))
(define (enclosing-environment env) (cdr env))

(define (make-frame bindings)
  (alist->hash-table bindings))

(define (add-binding-to-frame! var value frame)
  (hash-table-set! frame var value))

(define (extend-environment bindings base-environment)
  (cons (make-frame bindings) base-environment))


;; Lookup and Set Procedures
;;_______________________________________________________;;

(define (lookup-variable-value variable environment)
  (if (eq? environment the-empty-environment)
    (Error (print "Unbound variable:  " variable))
    (if (hash-table-exists? (current-environment environment) variable)
        (hash-table-ref (current-environment environment) variable)
        (lookup-variable-value variable (enclosing-environment environment)))))
  
(define (set-variable! variable value environment)
  (add-binding-to-frame! variable value (current-environment environment)))




;;__________________________________________________________________________;;
;; Setup the Global Environment
;;__________________________________________________________________________;;

(define global-syntax-definitions (make-hash-table))
(define (add-syntax name procedure) 
  (hash-table-set! global-syntax-definitions name procedure))

(add-syntax 'symbol lookup-variable-value)
(add-syntax 'quote (lambda (exp env) (cadr exp)))
(add-syntax 'define eval-definition)
(add-syntax 'if eval-if)
(add-syntax 'lambda eval-lambda)
(add-syntax 'begin (lambda (exp env) (eval-sequence (cdr exp) env)))


(define primitives '())

(define (setup-environment)
  (let ((initial-env (extend-environment primitives the-empty-environment)))
    ;; Self-Evaluating Values
    (set-variable! 'True True initial-env)
    (set-variable! 'False False initial-env)
    (set-variable! 'the-empty-list '() initial-env)
    (set-variable! 'Void Void initial-env)
    (set-variable! '&args &args initial-env)
    (set-variable! '>>> >>> initial-env)
    ;; Primitive Procedures
    (set-variable! 'null? (cons 'primitive null?) initial-env)
    (set-variable! 'equal? (cons 'primitive equal?) initial-env)
    (set-variable! 'print (cons 'primitive print) initial-env)
    ;; Primitive List Procedures
    (set-variable! 'cons (cons 'primitive cons) initial-env)
    (set-variable! 'car (cons 'primitive car) initial-env)
    (set-variable! 'cdr (cons 'primitive cdr) initial-env)
    ;; Primitive Number Procedures
    (set-variable! '+ (cons 'primitive +) initial-env)
    (set-variable! '- (cons 'primitive -) initial-env)
    (set-variable! '/ (cons 'primitive /) initial-env)
    (set-variable! '* (cons 'primitive *) initial-env)
    ;; Access to the type system
    (set-variable! 'type (cons 'primitive type) initial-env)
    (set-variable! 'type? (cons 'primitive type?) initial-env)
    ;; Access to the unit-test framework
    (set-variable! 'test (cons 'primitive test) initial-env)
    initial-env))

(define the-global-environment (setup-environment))

;;__________________________________________________________________________;;
;; REPL
;;__________________________________________________________________________;;


(define (REPL)
  (display ": ")
  (let ((input (read)))
    (let ((output (meta-eval input the-global-environment)))
      (if (eq? output Void) (REPL)
                            (user-print output))))
  (REPL))

(define (user-print object)
  (print object))


;; Comment out (REPL) for debugging or using as a library
(REPL)


